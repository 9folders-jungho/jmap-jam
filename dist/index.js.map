{"version":3,"sources":["../src/client.ts","../src/capabilities.ts","../src/helpers.ts","../src/request-drafts.ts"],"sourcesContent":["import { EventSourcePolyfill } from \"event-source-polyfill\";\n\nimport {\n  getCapabilitiesForMethodCalls,\n  knownCapabilities,\n} from \"./capabilities\";\nimport {\n  expandURITemplate,\n  getErrorFromInvocation,\n  getResultsForMethodCalls,\n} from \"./helpers\";\nimport {\n  WithRevValues,\n  WithoutRefValues,\n  buildRequestsFromDrafts,\n  type DraftsProxy,\n  type InvocationDraft,\n} from \"./request-drafts\";\nimport {\n  type GetArgs,\n  type GetResponseData,\n  type LocalInvocation,\n  type Meta,\n  type Methods,\n  type ProxyAPI,\n  type RequestOptions,\n} from \"./types/contracts\";\nimport type * as JMAP from \"./types/jmap\";\nimport type * as JMAPMail from \"./types/jmap-mail\";\n\nexport type ClientConfig = {\n  /**\n   * The tokenType used to authenticate all requests. (bearer, basic, jwt ...)\n   */\n  tokenType: string;\n\n  /**\n   * The bearer token used to authenticate all requests\n   */\n  token: string;\n\n  /**\n   * The URL of the JMAP session resources\n   */\n  sessionUrl: string;\n\n  /**\n   * A map of custom entities and their required capability identifiers\n   *\n   * @example\n   * ```\n   * const client = createClient({\n   *   customCapabilities: {\n   *     \"Sandwich\": \"urn:bigco:params:jmap:sandwich\",\n   *     \"TextMessage\": \"foo:bar:jmap:sms\",\n   *     \"Spaceship\": \"myspaceship-jmap-urn\",\n   *   },\n   * });\n   * ```\n   */\n  customCapabilities?: Record<string, string>;\n};\n\nexport class JamClient<Config extends ClientConfig = ClientConfig> {\n  /**\n   * Headers to send with every request\n   */\n  authHeader: string;\n\n  /**\n   * All available capabilities (known and custom)\n   */\n  capabilities: Map<string, string>;\n\n  /**\n   * An immediately fetched session promise\n   */\n  session: Promise<JMAP.Session>;\n\n  constructor(config: Config) {\n    this.authHeader = `${config.tokenType} ${config.token}`;\n\n    this.capabilities = new Map<string, string>([\n      ...Object.entries(config.customCapabilities ?? {}),\n      ...Object.entries(knownCapabilities),\n    ]);\n\n    this.session = JamClient.loadSession(config.sessionUrl, this.authHeader);\n  }\n\n  /**\n   * Retrieve fresh session data\n   */\n  static async loadSession(sessionUrl: string, authHeader: string) {\n    return fetch(sessionUrl, {\n      headers: {\n        Authorization: authHeader,\n        Accept: \"application/json\",\n      },\n      cache: \"no-cache\",\n    }).then((res) => res.json());\n  }\n\n  /**\n   * Send a JMAP request containing a single method call\n   */\n  async request<\n    Method extends Methods,\n    Args extends GetArgs<Method, Args>,\n    Data extends GetResponseData<Method, Args>\n  >(\n    [method, args]: LocalInvocation<Method, Args>,\n    options?: RequestOptions\n  ): Promise<[Data, Meta]> {\n    const {\n      using = [],\n      fetchInit,\n      createdIds: createdIdsInput,\n    } = options ?? {};\n\n    // Assemble method call\n    const invocation: JMAP.Invocation<Args> = [method, args, \"r1\"];\n\n    // Build request\n    const body: JMAP.Request<[JMAP.Invocation<Args>]> = {\n      using: [\n        ...getCapabilitiesForMethodCalls({\n          methodNames: [method],\n          availableCapabilities: this.capabilities,\n        }),\n        ...using,\n      ],\n      methodCalls: [invocation],\n      createdIds: createdIdsInput,\n    };\n\n    // Ensure session is loaded (if not already)\n    const { apiUrl } = await this.session;\n\n    // Send request\n    const response = await fetch(apiUrl, {\n      method: \"POST\",\n      headers: {\n        Authorization: this.authHeader,\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n      ...fetchInit,\n    });\n\n    // Handle 4xx-5xx errors\n    if (!response.ok) {\n      let error: string | JMAP.ProblemDetails;\n      if (response.headers.get(\"Content-Type\")?.includes(\"json\")) {\n        error = (await response.json()) as JMAP.ProblemDetails;\n      } else {\n        error = await response.text();\n      }\n      throw error;\n    }\n\n    // Handle success\n    const {\n      methodResponses: [methodResponse],\n      sessionState,\n      createdIds,\n    } = (await response.json()) as JMAP.Response<[JMAP.Invocation<Data>]>;\n\n    const error = getErrorFromInvocation(methodResponse);\n    if (error) {\n      throw error;\n    }\n\n    return [\n      methodResponse[1],\n      {\n        sessionState,\n        createdIds,\n        response,\n      },\n    ];\n  }\n\n  async requestMany<\n    DraftsFn extends (b: DraftsProxy) => { [id: string]: InvocationDraft },\n    Returning extends ReturnType<DraftsFn>\n  >(\n    draftsFn: DraftsFn,\n    options: RequestOptions = {}\n  ): Promise<\n    [\n      {\n        [MethodId in keyof Returning]: Returning[MethodId] extends InvocationDraft<\n          infer Inv extends [Methods, WithRevValues<Record<string, any>>]\n        >\n          ? GetResponseData<Inv[0], WithoutRefValues<Inv[1]>>\n          : never;\n      },\n      Meta\n    ]\n  > {\n    // Extract options\n    const { using = [], fetchInit, createdIds: createdIdsInput } = options;\n\n    const { methodCalls, methodNames } = buildRequestsFromDrafts(draftsFn);\n\n    // Build request\n    const body: JMAP.Request = {\n      using: [\n        ...getCapabilitiesForMethodCalls({\n          methodNames,\n          availableCapabilities: this.capabilities,\n        }),\n        ...using,\n      ],\n      methodCalls,\n      createdIds: createdIdsInput,\n    };\n\n    // Ensure session is loaded (if not already)\n    const { apiUrl } = await this.session;\n\n    // Send request\n    const response = await fetch(apiUrl, {\n      method: \"POST\",\n      headers: {\n        Authorization: this.authHeader,\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n      ...fetchInit,\n    });\n\n    // Handle 4xx-5xx errors\n    if (!response.ok) {\n      let error: string | JMAP.ProblemDetails;\n\n      if (response.headers.get(\"Content-Type\")?.includes(\"json\")) {\n        error = (await response.json()) as JMAP.ProblemDetails;\n      } else {\n        error = await response.text();\n      }\n\n      throw error;\n    }\n\n    // Handle success\n    const { methodResponses, sessionState, createdIds } =\n      (await response.json()) as JMAP.Response;\n\n    const meta: Meta = {\n      sessionState,\n      createdIds,\n      response,\n    };\n\n    const errors = methodResponses\n      .map(getErrorFromInvocation)\n      .filter((e): e is NonNullable<typeof e> => e !== null);\n\n    if (errors.length > 0) {\n      throw errors;\n    }\n\n    return [\n      // @ts-expect-error TODO\n      getResultsForMethodCalls(methodResponses, { returnErrors: false }),\n      meta,\n    ];\n  }\n\n  /**\n   * Get the ID of the primary mail account for the current session\n   */\n  async getPrimaryAccount() {\n    return (await this.session).primaryAccounts?.[\"urn:ietf:params:jmap:mail\"];\n  }\n\n  /**\n   * Upload a blob\n   */\n  async uploadBlob(\n    accountId: JMAP.BlobUploadParams[\"accountId\"],\n    body: BodyInit,\n    fetchInit: RequestInit = {}\n  ) {\n    const { uploadUrl } = await this.session;\n\n    const params: JMAP.BlobUploadParams = {\n      accountId,\n    };\n\n    const url = expandURITemplate(uploadUrl, params);\n\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers: {\n          Authorization: this.authHeader,\n          Accept: \"application/json\",\n        },\n        body,\n        ...fetchInit,\n      });\n\n      if (!response.ok) {\n        if (response.headers.get(\"Content-Type\")?.includes(\"json\")) {\n          throw (await response.json()) as JMAP.ProblemDetails;\n        } else {\n          throw await response.text();\n        }\n      }\n\n      return (await response.json()) as JMAP.BlobUploadResponse;\n    } catch (cause) {\n      throw new Error(\"Failed to upload blob\", { cause });\n    }\n  }\n\n  /**\n   * Download a blob\n   */\n  async downloadBlob(\n    options: {\n      accountId: JMAP.BlobDownloadParams[\"accountId\"];\n      blobId: JMAP.BlobDownloadParams[\"blobId\"];\n      mimeType: JMAP.BlobDownloadParams[\"type\"];\n      fileName: JMAP.BlobDownloadParams[\"name\"];\n    },\n    fetchInit: RequestInit = {}\n  ) {\n    const { downloadUrl } = await this.session;\n\n    const params: JMAP.BlobDownloadParams = {\n      accountId: options.accountId,\n      blobId: options.blobId,\n      type: options.mimeType,\n      name: options.fileName,\n    };\n\n    const url = expandURITemplate(downloadUrl, params);\n\n    try {\n      const response = await fetch(url, {\n        method: \"GET\",\n        headers: {\n          Authorization: this.authHeader,\n        },\n        ...fetchInit,\n      });\n\n      if (!response.ok) {\n        if (response.headers.get(\"Content-Type\")?.includes(\"json\")) {\n          throw (await response.json()) as JMAP.ProblemDetails;\n        } else {\n          throw await response.text();\n        }\n      }\n\n      return response;\n    } catch (cause) {\n      throw new Error(\"Failed to download blob\", { cause });\n    }\n  }\n\n  /**\n   * Initiate an event source to subscribe to server-sent events\n   */\n  async connectEventSource(options: {\n    types: \"*\" | Array<JMAPMail.Entity>;\n    ping: number;\n    closeafter?: JMAP.EventSourceArguments[\"closeafter\"];\n  }, opts: { [key: string]: any }) {\n    const params: JMAP.EventSourceArguments = {\n      types: options.types === \"*\" ? \"*\" : options.types.join(\",\"),\n      closeafter: options.closeafter ?? \"no\",\n      ping: `${options.ping}`,\n    };\n\n    const { eventSourceUrl } = await this.session;\n\n    const url = expandURITemplate(eventSourceUrl, params);\n\n    const urlString = url.toString();\n\n    let evtOpts = {\n      headers: {}\n    };\n\n    if (this.authHeader != null) {\n      evtOpts.headers = {\n        Authorization: this.authHeader\n      }\n    }\n\n    if (opts != null) {\n      const tmpHeader = {\n        ...evtOpts.headers,\n        ...opts.headers\n      };\n\n      evtOpts = {\n        ...evtOpts,\n        ...opts,\n        headers: tmpHeader\n      }\n    }\n\n    return new EventSourcePolyfill(urlString, evtOpts);\n  }\n\n  /**\n   * A fluent API using {entity}.{operation} syntax\n   *\n   * @example\n   * ```ts\n   * const [emails] = await jam.api.Email.get({\n   *   accountId,\n   *   ids,\n   *   properties,\n   * });\n   *\n   * const [mailboxes] = await jam.api.Mailbox.query({\n   *   accountId,\n   *   filter: { name: \"Inbox\" },\n   * });\n   * ```\n   */\n  get api() {\n    return new Proxy<ProxyAPI>({} as ProxyAPI, {\n      get: (_, entity: string) =>\n        new Proxy(\n          {},\n          {\n            get: (__, operation: string) => {\n              return async (args: any, options?: RequestOptions) => {\n                const method = `${entity}/${operation}` as Methods;\n\n                return this.request([method, args], options);\n              };\n            },\n          }\n        ),\n    });\n  }\n\n  static isProblemDetails(value: unknown): value is JMAP.ProblemDetails {\n    return typeof value === \"object\" && value !== null && \"type\" in value;\n  }\n}\n","/**\n * Entities associated with their JMAP capability identifiers.\n */\nexport const knownCapabilities = {\n  // RFC8620\n  Core: \"urn:ietf:params:jmap:core\",\n  // RFC8621\n  Mailbox: \"urn:ietf:params:jmap:mail\",\n  Thread: \"urn:ietf:params:jmap:mail\",\n  Email: \"urn:ietf:params:jmap:mail\",\n  SearchSnippet: \"urn:ietf:params:jmap:mail\",\n  Identity: \"urn:ietf:params:jmap:submission\",\n  EmailSubmission: \"urn:ietf:params:jmap:submission\",\n  VacationResponse: \"urn:ietf:params:jmap:vacationresponse\",\n};\n\n/**\n * Regex to match an entity name from within a method name.\n */\nconst entityMatcher = /^(\\w+)\\//;\n\n/**\n * Given a list of method names, determine the entities and provide the capabilities\n * that are required to operate on them.\n */\nexport function getCapabilitiesForMethodCalls({\n  methodNames,\n  availableCapabilities,\n}: {\n  methodNames: Iterable<string>;\n  availableCapabilities: ReadonlyMap<string, string>;\n}) {\n  const capabilities = new Set<string>();\n\n  // For each method\n  for (const method of methodNames) {\n    // Get the entity\n    const entity = entityMatcher.exec(method)?.[1];\n    if (entity) {\n      // Get the capability\n      const capability = availableCapabilities.get(entity);\n      if (capability) {\n        // Add the capability\n        capabilities.add(capability);\n      }\n    }\n  }\n\n  return capabilities;\n}\n","import type { Invocation, ProblemDetails } from \"./types/jmap\";\n\n/**\n * Expands a URI template with the given parameters.\n *\n * [rfc6570](https://datatracker.ietf.org/doc/html/rfc6570)\n */\nexport function expandURITemplate(\n  template: string,\n  params: Record<string, string>\n): URL {\n  let expanded = template;\n\n  for (const [key, value] of Object.entries(params)) {\n    const parameter = \"{\" + key + \"}\";\n    if (!expanded.includes(parameter)) {\n      throw new Error(`Template \"${template}\" is missing parameter: ${key}`);\n    }\n    expanded = expanded.replaceAll(parameter, value);\n  }\n\n  return new URL(expanded);\n}\n\nexport function isErrorInvocation(\n  input: Invocation\n): input is Invocation<ProblemDetails> {\n  return input[0] === \"error\";\n}\n\nexport function getErrorFromInvocation<T extends Invocation>(\n  invocation: T\n): ProblemDetails | null {\n  if (isErrorInvocation(invocation)) {\n    return invocation[1];\n  }\n\n  return null;\n}\n\n/**\n * Note: This could be more defensive, but for now I'm willing to trust that JMAP\n * servers will follow the specs (meaning: each method call will have a response\n * with a matching ID, no duplicates, etc. if the status code is 2xx)\n */\nexport function getResultsForMethodCalls(\n  methodCallResponses: Array<Invocation<any>>,\n  { returnErrors }: { returnErrors: boolean }\n) {\n  return Object.fromEntries(\n    methodCallResponses.map(([name, data, id]) => {\n      if (!returnErrors) {\n        return [id, data];\n      }\n\n      if (name === \"error\") {\n        return [\n          id,\n          {\n            data: null,\n            error: data as ProblemDetails,\n          },\n        ];\n      } else {\n        return [\n          id,\n          {\n            data,\n            error: null,\n          },\n        ];\n      }\n    })\n  );\n}\n\nexport type Obj = Record<string, unknown>;\n\nexport type InvocationTemplate<T> = T extends [infer Name, infer Data]\n  ? [Name, Data, string]\n  : never;\n\nexport type HasAllKeysOfRelated<\n  R extends Record<string | number | symbol, unknown>,\n  T extends Record<keyof R, unknown>\n> = T;\n\nexport type IncludeValue<T, V> = {\n  [K in keyof T]: T[K] | V;\n};\n\nexport type ExcludeValue<T, V> = {\n  [K in keyof T]: Exclude<T[K], V>;\n};\n","import type { ExcludeValue, IncludeValue } from \"./helpers\";\nimport { LocalInvocation, Methods, Requests } from \"./types/contracts\";\nimport type { Invocation, JSONPointer, ResultReference } from \"./types/jmap\";\n\nexport type Ref<I = unknown> = ReturnType<InvocationDraft<I>[\"$ref\"]>;\n\nexport type WithRevValues<T> = IncludeValue<T, Ref>;\n\nexport type WithoutRefValues<T> = ExcludeValue<T, Ref>;\n\n/**\n * Symbol used to identify arguments that need to be transformed\n * into JMAP result references\n */\nconst r = Symbol(\"Result Reference\");\n\n/**\n * These instances represent partially-formed method calls\n * used within `requestMany`. They are transformed into standard\n * JMAP method calls before being sent to the server.\n */\nexport class InvocationDraft<I = unknown> {\n  #invocation: I;\n\n  constructor(invocation: I) {\n    this.#invocation = invocation;\n  }\n\n  /**\n   * Create a result reference that points to the result\n   * of a previous invocation.\n   */\n  $ref(path: JSONPointer) {\n    return {\n      [r]: {\n        path,\n        invocation: this.#invocation,\n      },\n    };\n  }\n\n  /**\n   * Determine if a value is a result reference placeholder\n   */\n  static isRef<I = unknown>(value: unknown): value is Ref<I> {\n    return typeof value === \"object\" && value !== null && r in value;\n  }\n\n  /**\n   * Transform InvocationDraft instances into fully-formed JMAP method calls\n   * by replacing result reference placeholders with JMAP result references\n   * and applying user-provided IDs.\n   */\n  static createInvocationsFromDrafts<T extends Record<string, InvocationDraft>>(\n    drafts: T\n  ) {\n    // Track method names\n    const methodNames = new Set<string>();\n\n    // Associate IDs with invocation references\n    const invocationToId = new Map<unknown, string>();\n\n    const methodCalls = Object.entries(drafts).map(([id, draft]) => {\n      const [method, inputArgs] = draft.#invocation as LocalInvocation<\n        any,\n        any\n      >;\n\n      invocationToId.set(draft.#invocation, id);\n      methodNames.add(method);\n\n      // Transform partial refs into full refs\n      const args = Object.fromEntries(\n        Object.entries(inputArgs).map(([key, value]) => {\n          if (InvocationDraft.isRef<any>(value)) {\n            const { invocation, path } = value[r];\n\n            return [\n              `#${key}`, // Convert key to use JMAP ref syntax\n              {\n                name: invocation[0], // Ref method\n                resultOf: invocationToId.get(invocation)!, // Ref ID\n                path,\n              } satisfies ResultReference,\n            ];\n          }\n\n          // Not a ref, return unmodified\n          return [key, value];\n        })\n      );\n\n      return [method, args, id] as Invocation;\n    });\n\n    return { methodCalls, methodNames };\n  }\n}\n\nexport type DraftsProxy = {\n  [Entity in keyof Requests as Entity extends `${infer EntityName}/${string}`\n    ? EntityName\n    : never]: {\n    [Method in Entity as Method extends `${string}/${infer MethodName}`\n      ? MethodName\n      : never]: <\n      Args extends {\n        [T in keyof Requests[Method]]: Requests[Method][T] | Ref;\n      }\n    >(\n      args: Args\n    ) => InvocationDraft<[Method, Args]>;\n  };\n};\n\nexport function buildRequestsFromDrafts<\n  R extends Record<string, InvocationDraft<unknown>>\n>(draftsFn: (p: DraftsProxy) => R) {\n  // Create a proxy to intercept {entity}.{operation} calls\n  const draftsProxy = new Proxy({} as DraftsProxy, {\n    get: (_, entity: string) =>\n      new Proxy(\n        {},\n        {\n          get: (__, operation: string) => {\n            return (args: unknown) => {\n              const method = `${entity}/${operation}` as Methods;\n\n              const invocation = [method, args] as LocalInvocation<\n                Methods,\n                any\n              >;\n\n              return new InvocationDraft(invocation);\n            };\n          },\n        }\n      ),\n  });\n\n  // Create invocation drafts\n  const drafts = draftsFn(draftsProxy);\n\n  // Create actual invocations\n  return InvocationDraft.createInvocationsFromDrafts(drafts);\n}\n"],"mappings":"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","names":["error"]}